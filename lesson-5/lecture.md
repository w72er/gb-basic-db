# Операторы, фильтрация, сортировка и ограничение

План:
* Операторы
* Условная выборка
* Сортировка и ограничения
* Предопределенные функции. Часть 1.
* Предопределенные функции. Часть 2.

## Операторы

Конструкции языка для преобразования данных.
+ - * / % div:
```sql
SELECT 3 + 5;
-- переименовать столбец
SELECT 3 + 5 AS xxx;

UPDATE tbl SET id = id + 10;
```

Если  строка не может быть приведена к числу, то она будет 0
`select 'd' + 'd'; -- 0`

Деление на 0 не вызывает падение, и получим null.
DIV - целочисленное деление, просто отбрасывается.
/ - деление с дробью
% - остаток от деления (mod - альтернатива)

Логический тип

Как и serial TRUE and FALSE - константы на tinyint = 1 and 0.
<=> безопасное стравнение с NULL (НЛО)
SELECT 2>3; -- 0
SELECT 2<3; -- 1
SELECT 2!=3, 2<>3 -- 1 1
SELECT NOT TRUE; -- 
сравнение с нулл всегда нул
2<=>null -- 0
null<=>null -- 1
is null, is not null - альтернатива

Логическое AND OR
```text
create table tbl (
 x int
 y int
 sum int as (x+y) -- вычисляется каждый раз
                  -- добавив в конец STORED поле будет храниться и даже можно по нему индексировать.
);
```

## Условная выборка

БД хранят миллионы записей, поэтому изменить строку - встречается довольно часто.

WHERE id > 2 and id <=4
WHERE id [NOT] BETWEEN 3 AND 4

WHERE id IN (1,2,5);

Если в списке null, то вернется null
2 IN ( 0, NULL ) -- null

WHERE id NOT in ();

LIKE позволяет использовать шаблон.
Преимущество над равно
%- любой символ и может находится везде в слове.,
_ - один '___' - любое слово из трех символов.

SELECT * FROM catalogs WHERE name LIKE '%ы';
При использовании LIKE столбец приводится к строке.

Регулярные выражения.

Более медленное выполение, зато гибкие.

RLIKE 'грам';
^ - начало строки. $ - конец строки.
| - альтернативы или логическое или.
RLIKE 'abc|abd'
[abc] есть ли любой символ в диапазоне
'r' RLIKE '[а-яё]' ё не в диапазоне
классы символов 7 [[:digit]]

Квантификаторы
? - вхождение символа
* - любое 
+ - 1 или более
    
Фигурные скобки - сколько раз символ должен входить в регулярное выражение.

## Сортировка и ограничения

Запрос выдает в порядке в котором они хранятся в базе. По мере удаления или обносления, порядок изменяется.
ORDER BY столбец, по которым сортируем данные.
SELECT * FROM catalogs ORDER BY name;

Предположим что цена должна быть отсортирована сначала по каталогу, а затем цене в каталоге.
SELECT id, catalog_id, price, name FROM products ORDER BY catalog_id, price;
Изменить порядок сортировки можем с помощью DESC;
SELECT id, catalog_id, price, name FROM products ORDER BY catalog_id DESC, price DESC;

Результат выборки может содержать тысячи записей, поэтому информацию представляют постранично. Обычно
пользователю хочется получить всего несколько записей. LIMIT

Вывод уникальных значений.

SELECT DISTINCT catalog_id FROM .. ORDER BY ..;

Уменьшим цену материнских плат на 10%, при этом только тех чья цена превышает 5000
select * from tbl where catalog_id = 2 and price > 5000;
UPDATE products SET price = 0.9 * price WHERE catalog_id = 2 and price > 5000;

Давайте удалим две самые дорогие позиции в products.
SELECT * FROM products ORDER BY price DESC LIMIT 2;
DELETE FROM products ORDER BY price DESC LIMIT 2;

## Предопределенные функции MYSQL

NOW() в рамках одного значения одно

DATE(NOW()) - приведение к дате.

Чтобы удобнее оперировать столбцами их можно переименовать [AS] можно опустить

DATE_FORMAT

UNIXSTAMP - кол-во секунд с 1970 занимает 4 байта

unix_timestamp('2018')
from_unix_timestamp(032)

to_days()
floor - округление
timestamp_diff();

ORDER by RAND() LIMIT 1;



А готов ли я к переменам?
INSERT ...;
SELECT LAST_INSERT_ID();

SELECT DATABASE() - информационная группа функций.



Насыщенность информацией и нет перерывов.
Даже пять минут посмотреть сейчас, это уже пять минут не смотреть потом. Сложно много делать за один раз, поэтому уж побольше сделать сейчас.

### математические
RAND
sqrt
create table distances (
id serial prim key,
x1, y1
x2, y2
distance double as (sqlt(pow(x1 - x2) + ))
)

a->>'$.x'

square DOUBLE AS (a * b * SIN(RADIANS(angle)))

ROUND, celling, floor - округление.

### строки

substring - извлечение строк.
concat

if:
- логическое выражение
- что выдать правда
- лож

case:

inet_aton inet_ntoa

uuid - уникальный 

# Агрегация данных

## Группировка данных

Результирующие записи могут иметь повторения.

Разбить таблицу мы можем по %.

Получить уникальные значения catalog_id:
SELECT DISTINCT * FROM products GROUP BY catalog_id;

Разобьем пользователей родившихся в 80, 90 и 20 годах
substring(birthday_at, 1, 3) - извлекаем 
Псевдоним вычисляемого поля с помощью AS
SELECT id, name, SUBSTRING(birthday_at, 1, 3) AS decade ORDER BY decade;
запрос завершится неудачей, поскольку каждая из групп содержит несколько пользователей, то не понятно кого выводить.
SELECT SUBSTRING(birthday_at, 1, 3) AS decade ORDER BY decade;

Какую пользу можно извлечь из сгруппированных значений.

count(*), as decade;

Задачи при помощи групп
GROUP_CONCAT(name) - извлечь из группы указанное поле

## Агрегационные функции

count(*) - считает строки в независимости от того поле нул или нет
Мы не просто получаем уникальное. Мы разбиваем таблицу на 2 группы.
Мы с помощью каунт считаем строки внутри группы.

count(DISTINCT id) подсчитаются уникальные стрроки с id.


Внутри агрегационных функций допустимо указывать вычисляемые значения. 

## Специальные возможности GROUP BY

Агрегационные функции предназначены для получения информации их
каждой группы.

Выбрать группы, где количество записей в группе больше либо равно двум.
SELECT
    COUNT(*) AS total,
    SUBSTRING(DATE(birthday_at, 1, 3)) AS decade
FROM
    users
GROUP BY
    decade

Мы не можем подставить агрегационное значение в условие where.
Для этого нужно использовать having вместо where.
HAVING без группировки можно использовать, тогда каждая строка
рассматиривается как отдельная группа.

обнаружить повторяющиеся значения.
SELECT
    GROUP_CONCAT(name),
    COUNT(*) AS total
FROM
    products
GROUP BY
    category_id
HAVING
    total > 1

Уникальность добились с помощью группировки по нескольким полям.
alter table products_new rename products;

Для группировки можем использовать вычисляемые значения.
ANY_VALUE(name)

with_rollup - посчитать все кол-ва записей.