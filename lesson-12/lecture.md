# Урок 12. Вебинар. Оптимизация запросов

Принцип будет сохраняться, но особенности различаться.
Но разбор плана запроса пригодится и для других СУБД. Есть книга
"MySQL по максимуму". Сейчас оптимизатор умнее, сейчас при `join`
c `where` он работает так же как и с `on`.

В книге по оптимизации сказано включите лог на 1 час, и все
медленные запросы будут в нем 
my.cnf
long-slow-queries=/logs/slow.log
long_query_time=5 --sec
log_queries_not_using_index=1 -- запросы без индекса

-- Если запросы на чтение привалируют, иначе кэш будет чиститься
-- что не принесет пользу. Поэтому протеструйте дает ли пользу
-- кэш.
query_cache_size=8M
query_cache_limit

Первым делом запрос обрабатывается кэшем.
Запрос обрабатывается анализатором, где строится дерево разбора
Затем препроцессор, который также возвращает дерево разбора.
Затем оптимизатор, который возвращает план запроса.

select *
from users
inner join profiles on users.id = profiles.user_id;

select *
from users, profiles
where users.id = profiles.user_id;

table
Иногда нужно маленькую объединить с большой и это будет быстрее,
чем наоборот. `STRAIGHT_JOIN` - задаем свой порядок.

type
Это важное поле, по которому можно определить скорость работы


## Пример 1

Самое логичное взять таблицу первой, из-за users.id = 1, так как
это константа.
`query cost` - позволяет оценить на сколько эффективен запрос,
чем меньше стоимость тем лучше. Использовать следует при сравнении
нескольких запросов.
Более ясную схему можем получить используя workbench, для этого
нужно выполнить запрос кликнув по значку молния с лупой.
Зеленые это то что хорошо, синие не плохо, а красные медленно и 
плохо.
Блок media_types пусть и full table scan, однако таблица состоит
из 4х записей.

type ALL для 4 записей игнорируем.
post_likes - possible keys = NULL не находит, и при добавлении
поле filtered меняется с 19000 на 100, повышается тем самым 
производительность.

Автор: При проектировании базы данных в практическом смысле, нужно
понять какие запросы будут использоваться в БД, и написав эти
запросы оптимально, проектировать БД с учетом оптимальных запросов.

## Пример 2

Тот же пример 1, но только через вложенные запросы, а не через
JOIN. Видим что изменился selected_type, появились dependent
subqueries.

Если уберем `users.id = 1`, то станет `type=ALL` и ничего с 
этим поделать нельзя и это нормально.

Если перепишем этот запрос на JOIN то по query costs они будут
дороже на порядок, чем подзапросы.
Над блоками располагается `query cost` и мы можем таким образом,
что сумма стоимостей вложенных блоков равна стоимости итогового.
Получается мы можем оптимизировать цену вложенного блока, чтобы
снизить итоговую стоимость запроса.

1:16:17

## Пример 3

Покажем что индексы не всегда работают эффективно.
Если ищем город по названию `name="Moscow"` или `name LIKE
"Moscow"`, то будет использоваться индекс, однако в выражении
`name LIKE "%Moscow"` индекс использоваться не будет.

## Обобщаем

* Если мы видим в колонке extra: using file sort, после того как
  результат получен, не согласована сортировка и группировка
  using temporary  - база должна создать временную таблицу, что
  занимает время и снижает производительность.
  
Type
* all -- плохо
* index -- плохо
* range -- плохо
* ref
* eq_ref
* const
* system

Индексы не используются
* where col1 > col2, (<, >=, <=)
* where col1 is not null
* where col1 not in ()
* where col1 != expr
* where col1 LIKE "%pattern"

не используйте выражения от индексных столбцов
select 
where upper(index_field) = ''

Для фильтрации записей используйте WHERE, а не HAVING,
поскольку запросы с HAVING выполняются без индексов,
плюс нарушается семантика, так как предназначено для
работы с агрегированными результатами, где не учитывает
индексы.

Для составного индекса используйте первые столбцы.

На маленьких таблицах не используйте индексы:
* Если таблица маленького размера, то не используйте индексы.
* При выборе из таблицы 15-25% строк полный просмотр быстрее, чем
сканирование через индекс.

Стройте индексы по полям, по которым будет сортировка.

Сократите число просмотров одной таблицы
Лучше нагрузите не проход одной таблицы, а условие соответствия
`WHERE`.

Для более быстрого объединения используйте первой таблицу с меньшим
количеством строк.

Используйте результат оптимизатора повторно.
Оптимизатор хранит ранее вычисленные преобразования в памяти,
поэтому будет их использовать как кэш. Составляя подобные запросы,
новые запросы будут выполняться быстрее.

Помните, что рекомендации очень сильно зависят от версии сервера,
поэтому перепроверяйте результаты.

Рекомендации взяты из курса МГУ на степике.

## Курсовая

Требования прикреплены к 12 уроку
На сдачу отводится 10 дней, если хотите получить обрат связь,
то загрузите пораньше и напишите, если получится — проверю.

ER-диаграмма db -> reverse engineering, выбираем базу,
потом далее далее
и если сохранить с расширением m.., то будет супер, или сдайте
картинкой.

Дамп подойдет так же прекрасно.

Автор: желает удачи, по старанию и продуктивности.

